[General]
sim-time-limit = 30s
seed-set = 918273
description = "Tutorial 2"
network = d6g.simulations.training_day.solution2.NetworkSolution2

**.hasOutgoingStreams = true
*.listener.numApps = 2
*.listener.app[*].typename = "UdpSinkApp"
*.listener.app[0].io.localPort = 1042
*.listener.app[1].io.localPort = 1043

**.streamIdentifier.identifier.mapping = [{stream: "stream1", packetFilter: expr(udp.destPort == 1042)},
                                          {stream: "stream2", packetFilter: expr(udp.destPort == 1043)}]

**.streamCoder.*.mapping = [{stream: "stream1", pcp: 7},
						    {stream: "stream2", pcp: 6}]

**.numTrafficClasses = 7

[Task1]
extends = General
*.talker1.numApps = 1
*.talker1.hasOutgoingStreams = true
*.talker1.app[*].typename = "UdpSourceApp"
*.talker1.app[*].display-name = "stream1"
*.talker1.app[*].io.destAddress = "listener"
*.talker1.app[*].source.packetLength = 100B - 58B # 58B = 4B (Q-Tag) + 8B (UDP) + 20B (IP) + 14B (ETH MAC) + 4B (ETH FCS) + 8B (ETH PHY)
*.talker1.app[0].io.destPort = 1042
*.talker1.app[0].source.productionInterval = 10ms

# Task 1a)
# This task only takes place in the network_tutorial2.ned file.
# Your task is to change the type of the detCom device to a DetCom node.
# 
# Make yourself familiar with the structure of the DetCom node:
# https://deterministic6g.github.io/deterministic6g/doc/neddoc/d6g.devices.DetCom.html
# 
# The listener should be connected to the network side of the simulator.
# All other devices should be connected as wireless devices.

# Task 1b)
# Confirm that your network works as intended.
# 1. Run the simulation
# 2. Create an .anf file and generate a graph that shows the end to end delay (meanBitLifetimePerPacket) of each packet.


[Task2]
extends = Task1

*.talker2.numApps = 1
*.talker2.hasOutgoingStreams = true
*.talker2.app[*].typename = "UdpSourceApp"
*.talker2.app[*].display-name = "stream2"
*.talker2.app[*].io.destAddress = "listener"
*.talker2.app[*].source.packetLength = 100B - 58B # 58B = 4B (Q-Tag) + 8B (UDP) + 20B (IP) + 14B (ETH MAC) + 4B (ETH FCS) + 8B (ETH PHY)
*.talker2.app[0].io.destPort = 1043
*.talker2.app[0].source.productionInterval = 10ms
*.talker2.app[0].source.initialProductionOffset = 5ms

# As you saw in the previous task, the end-to-end delay is static.
# Delays within the DetCom node are typically variable.

# Task 2a)
# Your task is to setup the uplink delay in the DetCom node.
# - The connection of talker1 should use a given Histogram as a delay source.
# 	Use uplink_given.xml (you can see a plot of it in uplink_given.png, it has a mean delay of 5.6ms)
# - The connection of talker2 should experience a normal distribution with the following parameters o=2.5ms, u=100us in the DetCom node
# 
# The following documentation might be helpful:
# - Setting up delays in the DetCom node:
# 	https://deterministic6g.github.io/deterministic6g/doc/neddoc/d6g.devices.tsntranslator.TsnTranslator.html
# - Reading Histogram files:
# 	https://deterministic6g.github.io/deterministic6g/doc/neddoc/d6g.distribution.histogram.HistogramContainer.html
# 	The NED function to draw delays from the Histogram: quantity rngProvider(string rngProviderModule, string key?) 
# 		(Example usage here: https://deterministic6g.github.io/deterministic6g/doc/simulations/edgecloud/doc/index.html )

*.histogramContainer.histograms = {uplink: "../tutorial2/uplink_given.xml"}
*.detCom.dstt[0].delayUplink = rngProvider("histogramContainer", "uplink")
*.detCom.dstt[1].delayUplink = normal(2.5ms, 100us)

# Task 2b
# 1. Run the simulation
# 2. In your .anf file, create two Histogram figures showing the end-to-end delays for both streams
# 3. Make sure the Histograms match your expectations (compare the outcoming Histogram with uplink_given.png and the expected normal distribution)

[Task3a]
extends = Task2
# Timings without detCom delay: 8.050us per Link
# talker -> detCom: 	[0us, 		8.050us]
# detCom -> bridge: 	[8.050us, 	16.100us]
# bridge -> listener: 	[16.100us,	24.150us]

*.bridge.hasEgressTrafficShaping = true
*.bridge.eth[1].macLayer.queue.transmissionGate[6].offset = 10ms - 16.10us - 5.6ms # cycle time - ethernet delay - mean detCom delay
*.bridge.eth[1].macLayer.queue.transmissionGate[6].durations = [10us, 9990us]
*.bridge.eth[1].macLayer.queue.transmissionGate[5].offset = 10ms + 5ms - 16.10us - 2.5ms # cycle time + production offset - ethernet delay - mean detCom delay
*.bridge.eth[1].macLayer.queue.transmissionGate[5].durations = [10us, 9990us]

# You are now given a schedule that works for wired network.
# It is configured to use the mean delays of your confiured distributions
# Task 3a)
# 1. Execute the simulation
# 2. Explore the resulting end-to-end delays. What do you discover?

[Task3b]
extends = Task3a

# Task 3b)
# Your task now is to fix the given schedule, so that both streams meet their reliability demands.
# The reliability per stream is defined as the percentage of frames that arrive within their deadline.
# The deadline of both streams is the end of each cycle (10ms cycle time as defined above)

# Stream 1: 50% reliability
# We already provided you with the gate opening time to open at the minimal delay of (~4.183ms) as defined by the uplink_given.xml
*.bridge.eth[1].macLayer.queue.transmissionGate[6].offset = 10ms - 16.10us - 4.183ms # cycle time - ethernet delay - minimum detCom delay
# Use accumulated_bin_counts.csv to figure out the opening time to reach 50% reliability:
# TODO: REMOVE SOLUTION!
# 50% limit: 5.596ms
# Minimum delay: 4.183ms
# => Opening duration: 1.413ms
*.bridge.eth[1].macLayer.queue.transmissionGate[6].durations = [1.413ms, 10ms-1.413ms]

# Stream 1: 99.7% reliability
# With a normal distribution a reliability of 99.7% can be reached by cropping the distribution to the intveral [u-3o, u+3o]
# 	(u=2.5ms, o=100us as defined by you above)

# Again, we already provide you the upper limit:
*.bridge.eth[1].macLayer.queue.transmissionGate[5].offset = 10ms + 5ms - 16.10us - (2.5ms-300us) # cycle time - ethernet delay - (u-3o)
# Calculate the gate opening times as above
# TODO: REMOVE SOLUTION
*.bridge.eth[1].macLayer.queue.transmissionGate[5].durations = [600us, 10ms-600us]

# Task 3c)
# Explore the results:
# - Run the simulation
# - Explore Graphs in the .anf file
# - Compare the end-to-end delay of both streams regarding their target reliability
# - What happens with early/late frames?

[Task4]
# For fast people: PSFP
# TODO
