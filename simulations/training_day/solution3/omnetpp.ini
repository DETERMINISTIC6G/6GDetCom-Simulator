[General]
sim-time-limit = 10s
description = "abstract"

# enable time synchronization in all network nodes
*.*.hasTimeSynchronization = true

# all Ethernet interfaces have 100 Mbps speed
*.*.eth[*].bitrate = 100Mbps

*.visualizer.typename = "IntegratedMultiCanvasVisualizer"
*.visualizer.infoVisualizer[*].displayInfos = true

# Set all reference clocks to master clock so the time difference can be visualized
**.referenceClock = "tsnClock.clock"

# data link visualizer displays gPTP time synchronization packets
*.visualizer.dataLinkVisualizer[0].displayLinks = true
*.visualizer.dataLinkVisualizer[0].activityLevel = "protocol"
*.visualizer.dataLinkVisualizer[0].packetFilter = "GptpSync"
*.visualizer.dataLinkVisualizer[0].lineColor = "blue2"

*.visualizer.numInfoVisualizers = 3
*.visualizer.infoVisualizer[0].modules = "*.tsnClock.clock"
*.tsnClock.clock.displayStringTextFormat = "time: %T"
*.visualizer.infoVisualizer[1].modules = "*.tsnSwitch.clock"
*.visualizer.infoVisualizer[1].placementHint = "topLeft"
*.visualizer.infoVisualizer[2].modules = "*.tsnDevice*.clock"
*.visualizer.infoVisualizer[2].placementHint = "bottom"
*.tsnDevice*.clock.displayStringTextFormat = "diff: %d"
*.tsnSwitch.clock.displayStringTextFormat = "diff: %d"

[Config Task1]
network = d6g.simulations.training_day.tutorial3.NetworkTutorial3
description = "Basic tree topology with one master clock"

*.tsnSwitch.clock.initialClockTime = 10us
*.tsnDevice1.clock.initialClockTime = 20us
*.tsnDevice2.clock.initialClockTime = 30us

# Task 1: Setup basic gPTP network
# Parameters:
# gptpNodeType:
# 	MASTER_NODE, BRIDGE_NODE or SLAVE_NODE
# masterPorts:
# 	This device is the master of a device connected to a master port (i.e. transmits Sync messages)
# 	Array of interface names (e.g. ["eth0"])
# slavePort:
# 	This device is a slave of the device connected to the slave port
# 	Single interface name (e.g. "eth0")

# Task a): Setup the gPTP modules in your network for all devices.
*.tsnClock.gptp.gptpNodeType = "MASTER_NODE"
*.tsnClock.gptp.masterPorts = ["eth0"]

*.tsnSwitch.gptp.gptpNodeType = "BRIDGE_NODE"
*.tsnSwitch.gptp.slavePort = "eth0"
*.tsnSwitch.gptp.masterPorts = ["eth1", "eth2"]

*.tsnDevice*.gptp.gptpNodeType = "SLAVE_NODE"
*.tsnDevice*.gptp.slavePort = "eth0"

# Task b)
# - Run the simulation
# - Verify with the .anf file that all clocks are synchronized initially

[Config Task2]
extends = Task1
description = "Learning about constant clock drift"

*.tsnSwitch.clock.initialClockTime = 0us
*.tsnDevice1.clock.initialClockTime = 0us
*.tsnDevice2.clock.initialClockTime = 0us

# Task 2: Constant Clock Drift
# We now introduce drifting clocks, as real clocks are not perfect
# The IEEE802.1AS standard defines the driftRate must be within +/- 100ppm.
# 
# Task 2a) 
# Use a built-in OMNeT++ function to randomly generate an initial drift rate within this range.

**.clock.oscillator.typename = "ConstantDriftOscillator"
**.clock.oscillator.driftRate = uniform(-100ppm, 100ppm) # TODO: Change

# Task b)
# - Run the simulation
# - See in the .anf file how the graph changed
# - What happens at 0.125s and 0.25s?

[Config Task3]
extends = Task2
description = "Learning about changing clock drift"

# Task 3: Changing Clock Drift
# In reality the clock drift of a clock are typically not constant.
#
# The RandomDriftOscillator allows to change the drift rate by d ppm every t timeunits.
# RandomDriftOscillator has the following parameters:
# - changeInterval: t as defined above
# - driftRateChange: d as defined above, a new value is picked every t timeunits from the provided distribution
# - driftRateChangeLowerLimit: lower limit of the random walk process, i.e. ensures the drift rate is smaller than driftRateChangeLowerLimit
# - driftRateChangeUpperLimit: upper limit of the random walk process, i.e. ensures the drift rate is greater than driftRateChangeUpperLimit
#
# Task 3a) Setup changing clock drifts in the simulation
# - Think about a combination of t and d that you think is realistic and suitable for a simulation
# - Ensure the requirements of the standard as described in Task 2 is still kept

**.clock.oscillator.typename = "RandomDriftOscillator"
# [YOUR SOLUTION]
**.oscillator.changeInterval = 12.5ms
**.oscillator.driftRate = uniform(-100ppm, 100ppm)
**.oscillator.driftRateChange = uniform(-1ppm, 1ppm)
**.oscillator.driftRateChangeUpperLimit = 100ppm
**.oscillator.driftRateChangeLowerLimit = -100ppm

# Task 3b)
# - Run the simulation
# - Explore the graph in the .anf file

# Task 3c)
# As you can see, every clock performs a time jump after a received Sync+FollowUp message
# Why might this be problematic?
# 
# Do you have ideas on how to mitigate these problems?
# 
